<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Beam Modal Solver</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <style>
    body { background: #f4f4f4; font-family: sans-serif; }
    #beamCanvas { border: 1px solid #ccc; margin-top: 12px; cursor: pointer; background: #fff; }
    .swal2-popup { font-size: 12px !important; width: auto !important; min-width: 250px !important; }
    .swal2-input, .swal2-select { font-size: 12px !important; width: 120px !important; margin: 5px !important; }
    .swal2-html-container label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
    .swal2-html-container label span { margin-right: 10px; }
    .toolbar { display: grid; grid-template-columns: repeat(5, auto); gap: 6px; align-items: center; }
    .results { margin-top: 8px; font-size: 14px; }
    .muted { color:#666; font-size: 12px; }
    .modeCanvas { display:block; margin: 12px 0; border: 1px solid #ccc; background:#fff; }
    #modeToggles label { margin-right: 10px; cursor: pointer; }
    #animControls label { margin-left: 12px; }
    #animControls button { margin-left: 6px; }
      /* Hard-fix for hosts that hide label text (e.g., CMS themes that offscreen labels) */
    .toolbar label { display: inline-flex; align-items: center; gap: 6px; color: #000 !important; text-indent: 0 !important; }
    .toolbar label::before { content: none !important; }
    .toolbar label .field-text { color:#000 !important; font-size:14px !important; display:inline !important; }
.toolbar label { gap: 4px; }
    .toolbar input[type=number] { width: 60px; padding: 2px 4px; height: 26px; }
    #numSegments { width: 32px; }
    #gravityInput { width: 32px !important; }
    .toolbar button { padding: 4px 10px; font-size: 12px; line-height: 1.1; height: 28px; }
</style>
</head>
<body>
  <h2>Beam Modal Solver</h2>

  <div class="toolbar">
    <label><span class="field-text">Segments (max 10):</span> <input id="numSegments" type="number" min="1" max="10" value="4"></label>
    <label><span class="field-text">Gravity (G):</span> <input id="gravityInput" type="number" value="386" style="width:64px"></label>
    <button onclick="buildBeam()">Build Beam</button>
    <button onclick="computeModesRefined()">Compute Modes</button>
  </div>

  <canvas id="beamCanvas" width="900" height="220"></canvas>
  <div id="freqList" class="results"></div>
  <div id="modeToggles" class="results"></div>
  <div id="animControls" class="results">
    <strong>Animate:</strong>
    <button id="btnPlay" disabled>Play</button>
    <button id="btnPause" disabled>Pause</button>
    <label>Mode <select id="animMode" style="width:60px"></select></label>
    <label>Speed ×<input id="animSpeed" type="range" min="0.01" max="1" step="0.01" value="1" style="vertical-align: middle; width:120px"> <span id="animSpeedVal">1.00</span></label>
    <label>Amp ×<input id="animAmp" type="range" min="0.2" max="1.5" step="0.1" value="1" style="vertical-align: middle; width:120px"> <span id="animAmpVal">1.0</span></label>
    <span class="muted">(animates the selected mode only)</span>
  </div>
  <canvas id="modesCombined" width="900" height="340" class="modeCanvas"></canvas>

<script>
// --- configuration ---
const INTERNAL_NODES_PER_SEG = 10; // fixed refinement (m)

let segments = [];
let nodes = [];      // primary nodes only (length = S+1)
let lastModes = null; // [{lambdaGEP, freq, vec(full DOF)}] on refined grid

// animation state
const anim = { running:false, rafId:0, t0:0, modeIndex:0, speed:1, amp:1 };

function getRefine(){ return INTERNAL_NODES_PER_SEG; } // keep API, but constant

function buildBeam() {
  stopAnimation();
  const S = Math.max(1, Math.min(10, parseInt(document.getElementById("numSegments").value)));
  const totalL = 96; // arbitrary default total length in length units
  // reset segments
  segments = [];
  for (let i = 0; i < S; i++) {
    segments.push({ E: 12e6, I: 21.3, L: totalL / S, rho: 0.28, A: 2.0 });
  }
  // primary nodes only (S+1)
  nodes = Array(S + 1).fill().map(() => ({ bc: "free", W: 0, Kv: 0, Kr: 0 }));
  drawBeam();
  // reset UI areas
  lastModes = null;
  renderFreqList([]);
  buildModeToggles(0);
  buildAnimControls(0);
  renderCombinedModes();
}

async function editSegment(i){
  const s = segments[i];
  const { value: data } = await Swal.fire({
    title: `Segment ${i} Properties`,
    html:
      `<label><span>E:</span><input id="segE" class="swal2-input" value="${s.E}"></label>
       <label><span>I:</span><input id="segI" class="swal2-input" value="${s.I}"></label>
       <label><span>L:</span><input id="segL" class="swal2-input" value="${s.L}"></label>
       <label><span>ρ (dens):</span><input id="segRho" class="swal2-input" value="${s.rho}"></label>
       <label><span>A:</span><input id="segA" class="swal2-input" value="${s.A}"></label>`,
    focusConfirm:false,
    preConfirm:()=>[
      parseFloat(document.getElementById('segE').value),
      parseFloat(document.getElementById('segI').value),
      parseFloat(document.getElementById('segL').value),
      parseFloat(document.getElementById('segRho').value),
      parseFloat(document.getElementById('segA').value)
    ]
  });
  if (data){
    const [E,I,L,rho,A] = data.map(v=> (isFinite(v)? v:0));
    segments[i] = { E,I,L,rho,A };
    drawBeam();
  }
}

function drawBeam() {
  const canvas = document.getElementById("beamCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (segments.length === 0) return;
  const margin = 50;
  const midY = canvas.height/2;
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0);
  const scaleX = (canvas.width - 2 * margin) / totalLength;
  const maxEI = Math.max(...segments.map(seg => seg.E * seg.I));
  const maxHeight = 0.05 * canvas.height;

  let x = margin;
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    const width = seg.L * scaleX;
    const height = (seg.E * seg.I / maxEI) * maxHeight;
    ctx.fillStyle = "#666";
    ctx.fillRect(x, midY - height / 2, width, height);

    // segment text
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    const props = [ `E: ${seg.E}`, `I: ${seg.I}`, `L: ${seg.L}`, `ρ: ${seg.rho}`, `A: ${seg.A}` ];
    const startY = midY + height / 2 + 12;
    ctx.font = "12px sans-serif";
    for (let j = 0; j < props.length; j++) ctx.fillText(props[j], x + width / 2, startY + j * 14);

    // draw primary node at left end for first segment only
    if (i === 0) drawNodeFeatures(ctx, x, midY, nodes[0]);
    // draw primary node at right end of this segment
    const rightX = x + width;
    drawNodeFeatures(ctx, rightX, midY, nodes[i+1]);

    x += width;
  }
}

// Build primary node positions only (no internal nodes shown or clickable)
function buildPrimaryNodePositionMap(){
  const margin = 50; 
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0) || 1;
  const scaleX = (document.getElementById('beamCanvas').width - 2 * margin) / totalLength;
  const xs = [];
  let cumL = 0;
  xs.push(margin); // leftmost
  for (let i=0;i<segments.length;i++){
    cumL += segments[i].L;
    xs.push(margin + cumL * scaleX);
  }
  // indices are 0..S
  const is = xs.map((_,idx)=> idx);
  return { xs, is };
}

function drawNodeFeatures(ctx, x, y, node = { bc: 'free', W:0, Kv:0, Kr:0 }){
  ctx.save();
  ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.fillStyle = "black";

  // support glyphs
  if (node.bc === "pinned") {
    ctx.beginPath(); ctx.moveTo(x - 15, y + 17); ctx.lineTo(x, y); ctx.lineTo(x + 15, y + 17); ctx.closePath(); ctx.stroke();
  } else if (node.bc === "fixed") {
    ctx.beginPath(); ctx.moveTo(x - 5, y - 20); ctx.lineTo(x - 5, y + 20); ctx.moveTo(x + 5, y - 20); ctx.lineTo(x + 5, y + 20); ctx.stroke();
  }

  // Kv vertical spring (zig-zag below)
  if (node.Kv > 0) {
    ctx.beginPath(); let springY = y + 8; ctx.moveTo(x, springY);
    for (let i=0;i<4;i++){ ctx.lineTo(x + (i%2? -6:6), springY += 6); }
    ctx.lineTo(x, springY + 6); ctx.stroke();
  }

  // Kr rotational spring (same style as static solver)
  if (node.Kr > 0) {
    ctx.beginPath();
    ctx.moveTo(x-35, y-20);
    ctx.lineTo(x-25, y-20);
    ctx.lineTo(x-22, y-30);
    ctx.lineTo(x-16, y-10);
    ctx.lineTo(x-10, y-30);
    ctx.lineTo(x-8,  y-20);
    ctx.lineTo(x,    y-20);
    ctx.lineTo(x,    y+20);
    ctx.lineTo(x+8,  y+20);
    ctx.lineTo(x+10, y+30);
    ctx.lineTo(x+16, y+10);
    ctx.lineTo(x+22, y+30);
    ctx.lineTo(x+25, y+20);
    ctx.lineTo(x+35, y+20);
    ctx.stroke();
  }

  // node dot (large if W>0)
  const r = (node.W && node.W > 0) ? 8 : 4;
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

  // values label (W, Kv, Kr)
  function fmt(v){
    if (!isFinite(v)) return '0';
    const a = Math.abs(v);
    if (a >= 1000) return v.toFixed(0);
    if (a >= 100)  return v.toFixed(1);
    if (a >= 10)   return v.toFixed(2);
    if (a >= 1)    return v.toFixed(3);
    if (a >= 0.01) return v.toFixed(4);
    return v.toExponential(2);
  }
  ctx.fillStyle = "black"; ctx.textAlign = "center"; ctx.font = "11px sans-serif";
  const labels = [];
  if (Math.abs(Number(node.W)||0)  > 1e-12) labels.push(`W:${fmt(Number(node.W))}`);
  if (Math.abs(Number(node.Kv)||0) > 1e-12) labels.push(`Kv:${fmt(Number(node.Kv))}`);
  if (Math.abs(Number(node.Kr)||0) > 1e-12) labels.push(`Kr:${fmt(Number(node.Kr))}`);
  let y0 = y - 36;
  for (let i=0;i<labels.length;i++) ctx.fillText(labels[i], x, y0 - i*12);

  ctx.restore();
}

// Canvas click handler: edit segment or primary node
const beamCanvas = document.getElementById("beamCanvas");
beamCanvas.addEventListener("click", function (e) {
  const rect = beamCanvas.getBoundingClientRect();
  const xClick = e.clientX - rect.left;
  const yClick = e.clientY - rect.top;

  const margin = 50; 
  const midY = beamCanvas.height/2;
  const totalLength = segments.reduce((sum, seg) => sum + seg.L, 0);
  if (totalLength <= 0) return;
  const scaleX = (beamCanvas.width - 2 * margin) / totalLength;
  const maxEI = Math.max(...segments.map(seg => seg.E * seg.I)) || 1;
  const maxHeight = 0.05 * beamCanvas.height;

  // Primary node positions & indices only
  const map = buildPrimaryNodePositionMap();
  const nodeXs = map.xs;
  const nodeIs = map.is;

  // 1) Node hit test first
  const nodeHitR = 14;
  for (let k = 0; k < nodeXs.length; k++) {
    const dx0 = xClick - nodeXs[k];
    const dy0 = yClick - midY;
    if (Math.hypot(dx0, dy0) <= nodeHitR) {
      const idx = nodeIs[k];
      if (idx >= 0 && idx < nodes.length) editNode(idx);
      return;
    }
  }

  // 2) Segment hit test (exclude near nodes)
  let x = margin;
  for (let i = 0; i < segments.length; i++) {
    const seg = segments[i];
    const width = seg.L * scaleX;
    const height = (seg.E * seg.I / maxEI) * maxHeight;

    const left = x + nodeHitR + 2;
    const right = x + width - (nodeHitR + 2);

    if (right > left) {
      if (xClick >= left && xClick <= right && yClick >= (midY - height/2 - 10) && yClick <= (midY + height/2 + 10)) {
        editSegment(i);
        return;
      }
    }
    x += width;
  }
});

async function editNode(i) {
  if (i < 0 || i >= nodes.length) return; // safety
  const node = nodes[i] || { bc:'free', W:0, Kv:0, Kr:0 };
  const { value: data } = await Swal.fire({
    title: `Node ${i} Properties`,
    html:
      `<label><span>BC:</span><select id=\"bc\" class=\"swal2-select\">\n         <option value=\"free\" ${node.bc === 'free' ? 'selected' : ''}>Free</option>\n         <option value=\"pinned\" ${node.bc === 'pinned' ? 'selected' : ''}>Simple support (w=0, θ free)</option>\n         <option value=\"fixed\" ${node.bc === 'fixed' ? 'selected' : ''}>Fixed</option>\n       </select></label>\n       <label><span>W (lbf):</span><input id=\"W\" class=\"swal2-input\" value=\"${node.W}\"></label>\n       <label><span>Kv (lb/in):</span><input id=\"Kv\" class=\"swal2-input\" value=\"${node.Kv}\"></label>\n       <label><span>Kr (in·lb/rad):</span><input id=\"Kr\" class=\"swal2-input\" value=\"${node.Kr}\"></label>\n       <span class=\"muted\">Used in modal: Mww += W/G; Kww += Kv; Kθθ += Kr</span>`,
    focusConfirm: false,
    preConfirm: () => [
      document.getElementById("bc").value,
      parseFloat(document.getElementById("W").value),
      parseFloat(document.getElementById("Kv").value),
      parseFloat(document.getElementById("Kr").value)
    ]
  });
  if (data) nodes[i] = { ...nodes[i], bc: data[0], W: (isFinite(data[1])? data[1]:0), Kv: (isFinite(data[2])? data[2]:0), Kr: (isFinite(data[3])? data[3]:0) };
  drawBeam();
}

function computeModesRefined() {
  stopAnimation();
  if (!segments.length) { buildBeam(); return; }
  const m = getRefine(); // fixed 10 internal nodes/segment

  const g = parseFloat(document.getElementById("gravityInput").value) || 386;
  const S = segments.length; 
  const Nn_ref = S * (m + 1) + 1; // refined nodes
  const dofPerNode = 2; const N = dofPerNode * Nn_ref;

  const M = numeric.rep([N, N], 0); const K = numeric.rep([N, N], 0);

  // Assemble per sub-element (refinement) with CONSISTENT mass
  for (let i = 0; i < S; i++) {
    const seg = segments[i];
    const EI = seg.E * seg.I;
    const mu = (seg.rho / g) * seg.A; // mass/length
    const sub = m + 1; // elements per segment
    const Lsub = seg.L / sub;

    // refined node index at start of this segment in global refined list
    const startRef = i * (m + 1);

    for (let j = 0; j < sub; j++) {
      const n1 = startRef + j;
      const n2 = n1 + 1;
      const dofs = [ 2*n1, 2*n1+1, 2*n2, 2*n2+1 ];

      // stiffness (Hermite beam)
      const kLocal = [
        [12, 6*Lsub, -12, 6*Lsub],
        [6*Lsub, 4*Lsub*Lsub, -6*Lsub, 2*Lsub*Lsub],
        [-12, -6*Lsub, 12, -6*Lsub],
        [6*Lsub, 2*Lsub*Lsub, -6*Lsub, 4*Lsub*Lsub]
      ].map(r => r.map(v => v * EI / (Lsub*Lsub*Lsub)));

      for (let a=0;a<4;a++){
        for (let b=0;b<4;b++){
          K[dofs[a]][dofs[b]] += kLocal[a][b];
        }
      }

      // CONSISTENT mass matrix (Euler–Bernoulli)
      const c = mu * Lsub / 420;
      const mLocal = [
        [156,    22*Lsub,  54,    -13*Lsub],
        [22*Lsub, 4*Lsub*Lsub, 13*Lsub, -3*Lsub*Lsub],
        [54,     13*Lsub, 156,    -22*Lsub],
        [-13*Lsub, -3*Lsub*Lsub, -22*Lsub, 4*Lsub*Lsub]
      ].map(row => row.map(v => v * c));

      for (let a=0;a<4;a++){
        for (let b=0;b<4;b++){
          M[dofs[a]][dofs[b]] += mLocal[a][b];
        }
      }
    }
  }

  // Add nodal springs and extra lumped masses at PRIMARY nodes only
  for (let p=0; p<nodes.length; p++){
    const refIdx = p * (m + 1); // map primary to refined index
    const v = 2*refIdx, r = 2*refIdx+1;
    const W = Number(nodes[p].W)||0; const Kv = Number(nodes[p].Kv)||0; const Kr = Number(nodes[p].Kr)||0;
    if (W) M[v][v] += W / g;
    if (Kv) K[v][v] += Kv;
    if (Kr) K[r][r] += Kr;
  }

  // constraints from BC at PRIMARY nodes only
  const constrained = new Set();
  for (let p=0; p<nodes.length; p++){
    const bc = nodes[p].bc; const refIdx = p * (m + 1); const v = 2*refIdx, r = 2*refIdx+1;
    if (bc === 'fixed' || bc === 'pinned') { constrained.add(v); if (bc === 'fixed') constrained.add(r); }
  }
  const free = []; for (let i=0;i<N;i++){ if(!constrained.has(i)) free.push(i); }
  if (!free.length) { Swal.fire("Error", "All DOFs are constrained."); return; }

  const Kred = submat(K, free); const Mred = submat(M, free);

  // Direct eigensolve of inv(M)K (ω²), keep up to 3 modes
  let A; try { A = numeric.dot(numeric.inv(Mred), Kred); } catch(e){ Swal.fire('Error','M is singular. Check W/g and density/area.','error'); return; }
  const eig = numeric.eig(A); const vals = eig.lambda.x; const V = eig.E.x; // assume real
  const pairs = vals.map((val, i) => ({ val: val, vec: V.map(row => row[i]) }))
                    .filter(p => p.val > 0 && isFinite(p.val))
                    .sort((a,b)=> a.val-b.val)
                    .slice(0, 3);

  let modes = [];
  pairs.forEach(p => {
    const freq = Math.sqrt(p.val)/(2*Math.PI);
    const full = expandToFull(p.vec, free, N);
    const fullN = normalizeMode(full);
    modes.push({ lambdaGEP: p.val, freq, vec: fullN });
  });

  lastModes = modes;
  renderFreqList(modes);
  buildModeToggles(modes.length);
  buildAnimControls(modes.length);
  renderCombinedModes();
}

function buildModeToggles(count){
  const div = document.getElementById('modeToggles');
  div.innerHTML = '';
  if (!count) return;
  const label = document.createElement('span');
  label.textContent = 'Show modes:'; label.style.marginRight = '8px';
  div.appendChild(label);
  for (let i=1;i<=count;i++){
    const id = 'showMode' + i;
    const wrap = document.createElement('label');
    const cb = document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.checked = true; cb.style.marginRight='4px';
    cb.addEventListener('change', ()=>{ if (!anim.running) renderCombinedModes(); });
    wrap.appendChild(cb); wrap.append(`Mode ${i}`);
    wrap.style.marginRight = '10px';
    div.appendChild(wrap);
  }
}

function buildAnimControls(count){
  const btnPlay = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const sel = document.getElementById('animMode');
  sel.innerHTML = '';
  for (let i=1;i<=count;i++){
    const opt = document.createElement('option');
    opt.value = i-1; opt.textContent = i; sel.appendChild(opt);
  }
  const enabled = count > 0;
  btnPlay.disabled = !enabled; btnPause.disabled = true; sel.disabled = !enabled;
}

function submat(mat, idx){ return idx.map(i => idx.map(j => mat[i][j])); }
function expandToFull(vecRed, free, N){ const full = Array(N).fill(0); for(let i=0;i<free.length;i++){ full[free[i]] = vecRed[i]; } return full; }
function normalizeMode(full){ let maxAbs = 0; for (let i=0;i<full.length;i+=2){ const a = Math.abs(full[i]); if (a > maxAbs) maxAbs = a; } if (maxAbs < 1e-20) return full.slice(); return full.map(v => v / maxAbs); }

function renderFreqList(modes){
  const div = document.getElementById('freqList');
  if (!modes || !modes.length){ div.textContent = ''; return; }
  let html = '<strong>Frequencies (Hz):</strong> ' + modes.map((m,i)=> `f${i+1}=${m.freq.toFixed(3)}`).join(', ');
  html += ' <span class="muted">(mode shapes normalized to max |w| = 1; consistent element mass used)</span>';
  div.innerHTML = html;
}

function renderCombinedModes(){
  const canvas = document.getElementById('modesCombined');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width, canvas.height);
  if (!lastModes || !lastModes.length) return;

  const m = getRefine();
  // refined x positions across the entire beam (one per refined node)
  const xPositions = [];
  let x = 0;
  for (let i=0;i<segments.length;i++){
    const L = segments[i].L; const sub = m+1; const Lsub = L/sub;
    const start = (i===0) ? 0 : 1; // avoid duplicate of shared boundary
    for (let j=start; j<=sub; j++) xPositions.push(x + j*Lsub);
    x += L;
  }

  const totalLength = segments.reduce((s,sg)=>s+sg.L,0) || 1;
  const scaleX = canvas.width / totalLength;
  const offsetY = canvas.height/2;
  const scaleY = canvas.height * 0.4; // shapes normalized to ±1

  // guide lines: +1, 0, -1
  drawGuides(ctx, canvas, offsetY, scaleY);

  // which modes are selected?
  const selected = [];
  for (let i=0;i<lastModes.length;i++){
    const cb = document.getElementById('showMode' + (i+1));
    if (!cb || cb.checked) selected.push(i);
  }

  const colors = ['#1f77b4', '#2ca02c', '#d62728'];

  for (let idx of selected){
    const mode = lastModes[idx];
    const full = mode.vec; // full DOFs on refined grid

    // extract nodal deflections (every 2 entries)
    const w = []; for (let d=0; d<full.length; d+=2) w.push(full[d]);

    ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = colors[idx % colors.length];
    const n = Math.min(xPositions.length, w.length);
    for (let k=0;k<n;k++){
      const px = xPositions[k]*scaleX; const py = offsetY - (w[k]||0)*scaleY;
      if (k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  drawAxesAndLegend(ctx, canvas, lastModes, true);
}

function drawGuides(ctx, canvas, offsetY, scaleY){
  ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1; ctx.beginPath();
  ctx.moveTo(0, offsetY - 1*scaleY); ctx.lineTo(canvas.width, offsetY - 1*scaleY);
  ctx.moveTo(0, offsetY); ctx.lineTo(canvas.width, offsetY);
  ctx.moveTo(0, offsetY + 1*scaleY); ctx.lineTo(canvas.width, offsetY + 1*scaleY);
  ctx.stroke();
  ctx.fillStyle = '#666'; ctx.font = '12px sans-serif';
  ctx.fillText('+1', 4, offsetY - 1*scaleY - 4);
  ctx.fillText('0', 4, offsetY - 2);
  ctx.fillText('-1', 4, offsetY + 1*scaleY + 12);
}

function drawAxesAndLegend(ctx, canvas, modes, useToggles){
  // axes labels
  ctx.fillStyle = '#000'; ctx.font = '12px sans-serif';
  ctx.fillText('x (length units)', canvas.width - 140, canvas.height - 8);
  ctx.save(); ctx.translate(14, canvas.height/2); ctx.rotate(-Math.PI/2); ctx.fillText('Normalized deflection', 0, 0); ctx.restore();

  // legend
  const colors = ['#1f77b4', '#2ca02c', '#d62728'];
  const legendX = canvas.width - 260; let legendY = 18;
  for (let i=0;i<modes.length;i++){
    const mode = modes[i];
    const cb = document.getElementById('showMode' + (i+1));
    const visible = !useToggles || !cb || cb.checked;
    ctx.strokeStyle = colors[i % colors.length]; ctx.lineWidth = visible ? 3 : 1; ctx.globalAlpha = visible ? 1 : 0.3;
    ctx.beginPath(); ctx.moveTo(legendX, legendY); ctx.lineTo(legendX+22, legendY); ctx.stroke(); ctx.globalAlpha = 1;
    ctx.fillStyle = '#000';
    ctx.fillText(`Mode ${i+1} (f${i+1}=${mode.freq.toFixed(3)} Hz) ${visible ? '' : '(hidden)'}`, legendX + 28, legendY + 4);
    legendY += 18;
  }
}

// --- Animation ---
function startAnimation(){
  if (!lastModes || !lastModes.length) return;
  const sel = document.getElementById('animMode');
  anim.modeIndex = parseInt(sel.value||'0') || 0;
  anim.speed = parseFloat(document.getElementById('animSpeed').value)||1;
  anim.amp = parseFloat(document.getElementById('animAmp').value)||1;
  if (anim.running) cancelAnimationFrame(anim.rafId);
  anim.running = true; anim.t0 = performance.now();
  document.getElementById('btnPlay').disabled = true;
  document.getElementById('btnPause').disabled = false;
  const step = (ts)=>{ if (!anim.running) return; drawAnimatedFrame((ts-anim.t0)/1000); anim.rafId = requestAnimationFrame(step); };
  anim.rafId = requestAnimationFrame(step);
}
function stopAnimation(){
  anim.running = false; if (anim.rafId) cancelAnimationFrame(anim.rafId); anim.rafId = 0;
  const btnPlay = document.getElementById('btnPlay'); const btnPause = document.getElementById('btnPause');
  if (btnPlay) btnPlay.disabled = !(lastModes && lastModes.length);
  if (btnPause) btnPause.disabled = true;
  // redraw static
  renderCombinedModes();
}

function drawAnimatedFrame(t){
  const canvas = document.getElementById('modesCombined');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0,0,canvas.width, canvas.height);
  if (!lastModes || !lastModes.length) return;
  const mode = lastModes[Math.min(anim.modeIndex, lastModes.length-1)];

  const m = getRefine();
  // refined x positions
  const xPositions = [];
  let x = 0;
  for (let i=0;i<segments.length;i++){
    const L = segments[i].L; const sub = m+1; const Lsub = L/sub;
    const start = (i===0)?0:1; for (let j=start;j<=sub;j++) xPositions.push(x + j*Lsub);
    x += L;
  }
  const totalLength = segments.reduce((s,sg)=>s+sg.L,0) || 1;
  const scaleX = canvas.width / totalLength;
  const offsetY = canvas.height/2;
  const scaleY = canvas.height * 0.4 * anim.amp; // scale with amp

  // guides
  drawGuides(ctx, canvas, offsetY, canvas.height*0.4);

  // mode data
  const full = mode.vec; const w = []; for (let d=0; d<full.length; d+=2) w.push(full[d]);
  const omega = 2*Math.PI*mode.freq*anim.speed;

  ctx.beginPath(); ctx.lineWidth = 2.5; ctx.strokeStyle = '#1f77b4';
  const n = Math.min(xPositions.length, w.length);
  for (let k=0;k<n;k++){
    const px = xPositions[k]*scaleX; const py = offsetY - (w[k]||0)*scaleY * Math.sin(omega*t);
    if (k===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
  }
  ctx.stroke();

  drawAxesAndLegend(ctx, canvas, [mode], false);
}

// hook up anim controls
(function(){
  const btnPlay = document.getElementById('btnPlay');
  const btnPause = document.getElementById('btnPause');
  const sel = document.getElementById('animMode');
  const speed = document.getElementById('animSpeed');
  const amp = document.getElementById('animAmp');
  const speedVal = document.getElementById('animSpeedVal');
  const ampVal = document.getElementById('animAmpVal');
  if (btnPlay) btnPlay.addEventListener('click', startAnimation);
  if (btnPause) btnPause.addEventListener('click', stopAnimation);
  if (sel) sel.addEventListener('change', ()=>{ if (anim.running) startAnimation(); });
  if (speed) speed.addEventListener('input', ()=>{ speedVal.textContent = parseFloat(speed.value).toFixed(2); if (anim.running) startAnimation(); });
  if (amp) amp.addEventListener('input', ()=>{ ampVal.textContent = parseFloat(amp.value).toFixed(1); if (anim.running) startAnimation(); });
})();

function submat(mat, idx){ return idx.map(i => idx.map(j => mat[i][j])); }
function expandToFull(vecRed, free, N){ const full = Array(N).fill(0); for(let i=0;i<free.length;i++){ full[free[i]] = vecRed[i]; } return full; }
function normalizeMode(full){ let maxAbs = 0; for (let i=0;i<full.length;i+=2){ const a = Math.abs(full[i]); if (a > maxAbs) maxAbs = a; } if (maxAbs < 1e-20) return full.slice(); return full.map(v => v / maxAbs); }

// --- Test cases --- (primary nodes only in UI)
function testCantileverUniform(){
  const S = parseInt(document.getElementById('numSegments').value)||4;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 100, L: 100/S, rho: 0.283, A: 1.0}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc = 'fixed'; // left fixed
  drawBeam(); computeModesRefined();
}
function testSimplySupportedUniform(){
  const S = parseInt(document.getElementById('numSegments').value)||4;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 100, L: 120/S, rho: 0.283, A: 1.0}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc = 'pinned'; nodes[S].bc = 'pinned';
  drawBeam(); computeModesRefined();
}
function testFixedFixedUniform(){
  const S = parseInt(document.getElementById('numSegments').value)||4;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 100, L: 120/S, rho: 0.283, A: 1.0}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc = 'fixed'; nodes[S].bc = 'fixed';
  drawBeam(); computeModesRefined();
}
function testFixedPinnedUniform(){
  const S = parseInt(document.getElementById('numSegments').value)||4;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 100, L: 120/S, rho: 0.283, A: 1.0}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc = 'fixed'; nodes[S].bc = 'pinned';
  drawBeam(); computeModesRefined();
}
// Refined tests using fixed m=10 but properties only at primary nodes
function testSS_MidKv(){
  const S = 4; document.getElementById('numSegments').value = S;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 100, L: 200/S, rho: 0.283, A: 1.0}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc='pinned'; nodes[S].bc='pinned';
  const mid = Math.floor(S/2); nodes[mid].Kv = 1000; // translational spring at mid primary node
  drawBeam(); computeModesRefined();
}
function testCantileverTipMass(){
  const S = 3; document.getElementById('numSegments').value = S;
  segments = Array(S).fill(0).map(()=> ({E: 30e6, I: 80, L: 90/S, rho: 0.283, A: 0.8}));
  nodes = Array(S+1).fill(0).map(()=>({bc:'free', W:0, Kv:0, Kr:0}));
  nodes[0].bc = 'fixed'; nodes[S].W = 30; // lbf tip mass
  drawBeam(); computeModesRefined();
}

// expose tests (optional)
window.testCantileverUniform = testCantileverUniform;
window.testSimplySupportedUniform = testSimplySupportedUniform;
window.testFixedFixedUniform = testFixedFixedUniform;
window.testFixedPinnedUniform = testFixedPinnedUniform;
window.testSS_MidKv = testSS_MidKv;
window.testCantileverTipMass = testCantileverTipMass;

// Make buttons safe: expose globals
window.buildBeam = buildBeam;
window.computeModesRefined = computeModesRefined;

// initial
buildBeam();
</script>
</body>
</html>
